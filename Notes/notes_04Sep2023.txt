Day 6:
online session:
	12:30	lunch
	4:00 	break
	6:00	break
	8:00	dinner
Last day, we discussed about arrays.

Employee arr[]=new Employee[10];
new operator.
Pending:	array of objects.
------------------------------------------
Strings
	What is a String?
		basically a text within quotes.	
		single quote for a char. double quote for a string
		collection of characters.

char x='a';	
String y="Raja";

String is made up of characters.
c language, c++ language,there it was like char array was used as String.

char arr[10];	//in C, C++ language, we store 9 characters and the last position is for null terminator.		\0

String in java, does not need null terminator.	
Here, it is not an array of characters.

String was stored in a special memory location	
	PermGen		Permanent Generation memory

jdk 1.8 onwards, Strings are stored in heap.

Only heap memory is garbage collected.
	Garbage Collector 	
		is thread that runs parallel to our program.
		will find the objects that are out of scope and
		remove them from the memory.
String is very peculiar.

String is a class.
How do we create an object of a class?
String str1=new String();

Date dt1=new Date();

2 steps of creating an object of a class:
1) declaration ref var of the class		
2) instantiation	new	(creating an object of the class)


int i;		//i is created	(memory is allocated)
Date dt1;		//dt1 is declared	(stack)
dt1=new Date();	//memory is allocated in heap

new Date();	//an object of the class Date is created

without using "new" operator, we cannot create an object.

Date dt1=new Date();
Date dt2=dt1;	//did i create another object?	No. 
		dt2 also refers to the same memory of dt1

dt1 and dt2 are reference variables that are pointing to same memory

Date dt1=null;		dt1 is in stack
dt1=new Date();	heap memory is created, and its location is stored in dt1 in stack.

new Date();	//heap memory is created. But its reference is not 		kept in stack.

System.out.println(new Date());

String str1=new String("hello");	//fine
String str2="hello";		//peculiar

"hello" is an object. It is present in heap



==
.equals()



		String str1="hello";
		String str2="hello";
		
		System.out.println(str1==str2);

output is true
	because, str1 and str2 references to same memory location.

a==b	what is compared? values? or references?

==
	check if the values are equal(if operands are value types)
	check if the references are equal(if operands are ref types)

	
String is a reference type. So if you want to compare their values,
	str1.equals(str2)

---------------------
String str1=new String("hello");
String str2=new String("hello");
System.out.println(str1==str2);

output:	false

because, == compares the references of ref types.
-------------------------
	    String str1=new String("hello");
	    String str2=new String("hello");
// 		System.out.println(str1==str2);

        System.out.println(str1.equals(str2));

output: true
	because, equals() method always compare the values.

String
	is immutable.

we can't modify the string
str1=new String("hello");
str1="world";

str1=str2;		//is it possible. Yes.
same way,
str1="india";	//we have not changed the value. we changed the reference.

int i=20;
int j=i;		//values are copied.

= operator also, copies, values/ reference based on the type of variable.

so whenever we use = on a String, we are changing the reference.

we are actually creating a new string or changing the reference
it does not mean, we change the values.

string is not a variable that allow us to change the value alone.

String str="hello";

if you want to replace "h" with "H".

    String str="hello";
    str=str.substring(1);
    // System.out.println(str);
    str="H"+str;
    System.out.println(str);
		

What is mutable string?
	StringBuilder
	StringBuffer

advantage of these 2 classes:
	we can create an object in a memory location.
	memory location will be same.
	Only the values in it can be changed.

Activity:
	Understand the benefits of 
	StringBuilder
	StringBuffer

	and find the difference between these 2 classes.
StringBuilder
vs
StringBuffer
	both of these classes have same properties and methods.
	but StringBuffer is synchronized. StringBuilder is not sync

what is synchronized?
	when multiple thread access this object, only 1 thread is allowed at a time.	one by one the threads can access.
Apart from this difference, both StringBuilder and StringBuffer are same.

Since StringBuilder does not synchronize the threads, it is fast.
StringBuilder
-------------------
	str="hello";	//not possible in StringBuilder

StringBuilder sb=new StringBuilder("hello");
String str="hello";
sb=new StringBuilder(str);		//string is copied to sb
//or

sb.append(str);
sb.append("world");

append
replace
delete

Practise, 
	StringBuilder methods to append, replace, delete characters.
https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html



Pending:
	regex

--------------------------
How to convert a String into char array
If you convert, you will be able to access each character at a time

ex:
	Find if the input String is a palindrome or not.
what is a palindrome?
	a string, whose reverse is same as the original string.
ex:	
	madam
	malayalam
	mam
	dad
	mom

How to solve this problem?
1) we can reverse a string and find if it is same
2) compare char at index 0 with n-1 index char
	0+1	n-1-1
	0+2	n-1-2
	0+3	n-1-3
until startindex and end index cross eachother.

malayam
0=m	n-1-0=m
1=a	n-1-1=a
2=l	n-1-2=l
3=a	n-1-3=a		7-4=3	middle char
4=y	n-1-3		NO NEED TO PROCEED

traverse from left.	traverse from right.
when they cross, we can conclude.
To be able to work on this algorithm, we should be able to access each character at a time.

SonarQube	(code quality)
	commented java code are poor practice.
	comments that explain the code are good practice.


//to find if the input string is a palindrome or not
        Scanner sc=new Scanner(System.in);
        String input=sc.next();
        //access elements from left and also from right
        int n=input.length();   //String, length is a method () 
        //in arrays, length is a variable   arr.length  //no brackets
        for(int i=0;i<=n/2;i++)
        {
            // System.out.println(input.charAt(i)+" vs "+input.charAt(n-1-i));    
            if(input.charAt(i)!=input.charAt(n-1-i))
            {
                System.out.println("Not palindrom");
                System.exit(0);
            }
    	}
    	System.out.println("palindrom");


--------------------------------
we used charAt(index) in the above program.
---------------------------------
Another approach:
convert the String into char array

        //to find if the input string is a palindrome or not
        Scanner sc=new Scanner(System.in);
        String input=sc.next();
        char []arr=input.toCharArray();    //methods are in camelCase. first letter small. Every next word first letter is in upper case.
        int n=arr.length;
        for(int i=0;i<=n/2;i++)
        {
            if(arr[i]!=arr[n-1-i])
            {
                System.out.println("Not palindrome");
                return;
            }
        }
        System.out.println("palindrome");

----------------------------
String does not have reverse method.
StringBuilder has reverse() method

//to find if the input string is a palindrome or not
        Scanner sc=new Scanner(System.in);
        String input=sc.next();
        StringBuilder sb=new StringBuilder(input);
	//another way		sb.append(input);
        sb.reverse();
        System.out.println(sb); //println method automatically calls the toString() method 
        //sb.toString()
        
        // String temp=sb; //wrong      
        String temp=sb.toString();
        if(input.equals(temp))
            System.out.println("palindrome");
        else
            System.out.println("Not palindrome");

-----------------------------------------
sb.append(str);	//String to StringBuilder
str=sb.toString();	//StringBuilder to String
